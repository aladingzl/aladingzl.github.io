---
layout:     post
title:      "V8 垃圾回收"
subtitle:   "garbage collection"
date:       2022-1-15
author:     "aladingzl"
header-style: text
tags:
    - GC
    - JavaScript
    - 笔记
---

> 由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。《JavaScript权威指南（第四版）》

### V8引擎的内存限制

在 Node 中通过 JavaScript 使用内存时只能使用部分内存( 64位系统下约为 1.4GB, 32 位系统下约为 0.7GB)。在这样的限制下，将会导致Node 无法直接操作大内存对象，比如无法将一个 2 GB 的文件读人内存中进行字符串分析处理，即使物理内存有32 GB。这样在单 Node进程的情况下，计算机的内存资源无法得到充足的使用。造成这个问题的主要原因在于 Node 基于 V8 构建，所以在 Node 中使用的JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。V8 的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。但在 Node 中，这却限制了开发者随心所欲使用大内存的想法。

在 V8 中，所有 JavaScript 对象都是通过堆来进行分配的。当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止。

V8 为何要限制堆的大小？

表层原因为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8 的限制值已经绰绰有余。

深层原因是V8的垃圾回收机制的限制。

按官方的说法，以1.5 GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要 1 秒以上。这是垃圾回收中引起 JavaScript 线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受，前端浏览器也无法接受。因此，在当时的考虑下直接限制堆内存是一个好的选择。另外，V8 给我们提供了选项放宽内存，也可以通过 `process.memoryUsage()`方法查看当前node进程所占用的实际内存大小。

### V8的垃圾回收策略

V8的垃圾回收策略主要是基于**分代式垃圾回收机制**，不同的算法只能针对特定情况具有最好的效果。现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法。

**V8 的内存分代**

在 V8 中，主要将内存分为**新生代**和**老生代**两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。

![gc01](https://cdn.jsdelivr.net/gh/aladingzl/PicGoCDN//img/gc01.png)

在 V8 引擎的内存结构中，新生代主要用于存放存活时间较短的对象。新生代内存是由两个`semispace(半空间)`构成的，内存最大值在`64`位系统和`32`位系统上分别为`32MB`和`16MB`，在新生代的垃圾回收过程中主要采用了`Scavenge`算法。

**Scavenge 算法**

在`Scavenge`算法的具体实现中，主要采用了`Cheney`算法。

`Cheney` 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二， 每一部分空间称为 `semispace`。在这两个 `semispace`空间中，只有一个处于使用中，另一个处于闲置状态。 处于使用状态的 `semispace` 空间称为 From 空间，处于闲置状态的空间称为 To空间。当我们分配对象时，先是在 `From` 空间中进行分配。当开始进行垃圾回收时，会检查 `From` 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生对换。

简而言之，在垃圾回收的过程中，就是通过将存活对象在两个 `semispace` 空间之间进行复制。

`Scavenge` 的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。Scavenge 只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。

`Scavenge` 是典型的牺牲空间换取时间的算法，所以无法大规模地应用到所有的垃圾回收中。新生代中对象的生命周期较短，适合这个算法。

![gc02](https://cdn.jsdelivr.net/gh/aladingzl/PicGoCDN//img/gc02.png)

**对象晋升**

当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为`晋升`。
 对象晋升的条件主要有以下两个：

- 对象是否经历过一次`Scavenge`算法
- `To`空间的内存占比是否已经超过`25%`

在默认情况下，V8 的对象分配主要集中在 From 空间中。对象从 From 空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次 Scavenge 回收。如果已经经历过了，会将该对象从 From 空间复制到老生代空间中，如果没有，则复制到 To 空间中。这个晋升流程如图：

![gc03](https://cdn.jsdelivr.net/gh/aladingzl/PicGoCDN//img/gc03.png)



另一个判断条件是To空间的内存占用比。当要从From空间复制-一个对象到To空间时，如果 To 空间已经使用了超过25%。则这个对象直接晋升到老生代空间中，这个晋升的判断示意图如图

![gc04](https://cdn.jsdelivr.net/gh/aladingzl/PicGoCDN//img/gc04.png)

**Mark-Sweep & Mark-Compact**

老生代中的对象，存活对象占较大比重，采用 `Scavenge` 的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。

V8 在老生代中主要采用了 Mark-Sweep 和 Mark-Compact 相结合的方式进行垃圾回收。

Mark-Sweep 是**标记清除**的意思，它分为标记和清除两个阶段。与 Scavenge 相比， Mark Sweep并不将内存空间划分为两半,所以不存在浪费一半空间的行为。与 Scavenge 复制活着的对象不同，Mark Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象,在随后的清除阶段中，只清除没有被标记的对象。Scavenge 中 只复制活着的对象，而 Mark-Sweep 只清理死亡对象。活对象在新生代中只占较小部分，死对象在老生代中只占较小部分，这是两种回收方式能高效处理的原因。

![gc05](https://cdn.jsdelivr.net/gh/aladingzl/PicGoCDN//img/gc05.png)

Mark-Sweep 最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。
为了解决 Mark Sweep 的内存碎片问题，Mark-Compact被 提出来。Mark-Cormpact 是**标记整理**
的意思，对象在标记为死亡后,在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。
白色格子为存活对象，深色格子为死亡对象，浅色格子为存活对象移动后留下的空洞。

![gc06](https://cdn.jsdelivr.net/gh/aladingzl/PicGoCDN//img/gc06.png)

移动后，可以直接清除最右边存活对象。

![gc07](https://cdn.jsdelivr.net/gh/aladingzl/PicGoCDN//img/gc07.png)

V8 主要使用 Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用 Mark-Compact。

**Incrementl Marking**

为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的 3 种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为**全停顿( stop-the-world )**。在 V8 的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。但 V8 的老生代通常配置得较大，且存活对象较多，全堆垃圾回收( full 垃圾回收)的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。

为了降低全堆垃圾回收带来的停顿时间，V8 先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记( incremental marking)，也就是拆分为许多小“步进”，每做完一“步进”就让 JavaScript 应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。

![gc08](https://cdn.jsdelivr.net/gh/aladingzl/PicGoCDN//img/gc08.png)





**笔记摘自《深入浅出 Node.js》**

